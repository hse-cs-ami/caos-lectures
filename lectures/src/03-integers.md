# Целые числа

Двоичное представление:

\\( 42 = 32 + 8 + 2 = 2^5 + 2^3 + 2^1 = 101010_2 \\).

\\( 49 = 32 + 16 + 1 = 2^5 + 2^4 + 2^0 = 110001_2 \\).

Нумерация битов:

```c
     ... 0 0 1 1 0 0 0 1 = 49
     ... 7 6 5 4 3 2 1 0

<- старшие разряды
     младшие разряды ->
```

Ячейки памяти разного размера:

```c
8 бит:
00000000 = 0
11111111 = 255

16 бит:
0000000000000000 = 0
1111111111111111 = 65535
...
```

Шестнадцатеричные цифры:

```c
0000 0         1000 8
0001 1         1001 9
0010 2         1010 a
0011 3         1011 b
0100 4         1100 c
0101 5         1101 d
0110 6         1110 e
0111 7         1111 f
```

Например, `42 = 0b00101010 = 0x2A`. Полезно помнить некоторые степени двойки:

```c
2**8  = 256   =   0x100
2**10 = 1024  =   0x400
2**12 = 4096  =  0x1000
2**16 = 65536 = 0x10000
```

Переполнение 16-битной ячейки памяти:

```c
  0xffff  = 65535
+ 0x0001
= 0x0000

(должно было быть 0x10000, но старший бит не поместился)
```

Получается арифметика по модулю \\( 2^N \\), в данном случае — по модулю \\( 2^{16} = 65536 \\).

## Знаковые числа

Two's complement representation (два-дополнительный код) 
на примере 4-разрядных (4-битных) чисел:

| Биты | Число |
|------|------:|
0000 | 0
0001 | 1
0010 | 2
0011 | 3
0100 | 4
0101 | 5
0110 | 6
**0111** | 7
**1000** | -8
1001 | -7
1010 | -6
1011 | -5
1100 | -4
1101 | -3
1110 | -2
1111 | -1

Старший бит — знаковый.

«Переполнение» беззнаковых чисел здесь работает вполне логично:
```c
  0xffff  = -1
+ 0x0001
= 0x0000
```
